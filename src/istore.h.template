#ifndef ISTORE_H
#define ISTORE_H

#include <limits.h>

#include "postgres.h"

#include "avl.h"
#include "fmgr.h"
#include "utils/builtins.h"
#include "utils/memutils.h"

/*
 * creates the internal representation from a pairs collection
 */
#define FINALIZE_ISTORE_BASE(_istore, _pairs, _pairtype) \
        _istore         = palloc0(ISHDRSZ + PAYLOAD_SIZE(_pairs, _pairtype));\
        _istore->buflen = _pairs->buflen;\
        _istore->len    = _pairs->used;\
        SET_VARSIZE(_istore, ISHDRSZ + PAYLOAD_SIZE(_pairs, _pairtype));\
        memcpy(FIRST_PAIR(_istore, _pairtype), _pairs->pairs, PAYLOAD_SIZE(_pairs, _pairtype));

{%


/*
 * ${store} definitions
 */

/*
 * a single key/value pair
 */
typedef struct
{
    ${keytype} key;
    ${valtype} val;
} ${store}Pair;

/*
 * collection of pairs
 */
typedef struct
{
    ${store}Pair *pairs;
    size_t      size;
    int         used;
    int         buflen;
} ${store}Pairs;

/*
 * the istore
 */
typedef struct
{
    int32 __varlen;
    int32 buflen;
    int32 len;
} ${store};

void ${store_lower}_pairs_init(${store}Pairs *pairs, size_t initial_size);
void ${store_lower}_pairs_insert(${store}Pairs *pairs, ${keytype} key, ${valtype} val);
int ${store_lower}_pairs_cmp(const void *a, const void *b);
void ${store_lower}_tree_to_pairs(AvlNode *p, ${store}Pairs *pairs);

/*
 * get the ${store}
 */
#define PG_GETARG_${store_upper}(x) (${store} *) PG_DETOAST_DATUM(PG_GETARG_DATUM(x))
#define PG_GETARG_${store_upper}_COPY(x) (${store} *) PG_DETOAST_DATUM_COPY(PG_GETARG_DATUM(x))

#define FINALIZE_${store_upper}(_istore, _pairs) \
    do \
    { \
        FINALIZE_ISTORE_BASE(_istore, _pairs, ${store}Pair); \
        pfree(_pairs->pairs); \
    } while (0)


%}

//void           istore_copy_and_add_buflen(IStore *istore, BigIStorePair *pairs);
//void           bigistore_add_buflen(BigIStore *istore);

int is_int32_arr_comp(const void *a, const void *b);
int is_int64_arr_comp(const void *a, const void *b);

#define BUFLEN_OFFSET 8
#define MAX(_a, _b) ((_a > _b) ? _a : _b)
#define MIN(_a, _b) ((_a < _b) ? _a : _b)

#define PAIRS_MAX(_pairtype) (MaxAllocSize / sizeof(_pairtype))
#define PAYLOAD_SIZE(_pairs, _pairtype) (_pairs->used * sizeof(_pairtype))
#define ISHDRSZ VARHDRSZ + sizeof(int32) + sizeof(int32)

#define ISTORE_SIZE(x, _pairtype) (ISHDRSZ + x->len * sizeof(_pairtype))

/*
 * get the first pair of type
 */
#define FIRST_PAIR(x, _pairtype) ((_pairtype *) ((char *) x + ISHDRSZ))
#define LAST_PAIR(x, _pairtype)  ((_pairtype *) ((char *) x + ISHDRSZ + (x->len-1) * sizeof(_pairtype)))

#if 0
#define FINALIZE_ISTORE(_istore, _pairs)                   \
    do                                                     \
    {                                                      \
        FINALIZE_ISTORE_BASE(_istore, _pairs, IStorePair); \
        pfree(_pairs->pairs);                              \
    } while (0)

#define FINALIZE_BIGISTORE(_istore, _pairs)                   \
    do                                                        \
    {                                                         \
        FINALIZE_ISTORE_BASE(_istore, _pairs, BigIStorePair); \
        pfree(_pairs->pairs);                                 \
    } while (0)

#define FINALIZE_DATEISTORE(_istore, _pairs)                   \
    do                                                        \
    {                                                         \
        FINALIZE_ISTORE_BASE(_istore, _pairs, DateIStorePair); \
        pfree(_pairs->pairs);                                 \
    } while (0)
#endif

#define SAMESIGN(a,b)   (((a) < 0) == ((b) < 0))
#define INTPL(_a, _b, _r)                                                                                              \
    do                                                                                                                 \
    {                                                                                                                  \
        _r = _a + _b;                                                                                                  \
        if (SAMESIGN(_a, _b) && !SAMESIGN(_r, _a))                                                                     \
            ereport(ERROR, (errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE), errmsg("integer out of range")));             \
    } while (0)

#if 0
/*
 * return the number of digits
 */
static inline int
digits32(int32 num)
{
    int sign = 0;
    if (num < 0)
    {
        if (num == INT_MIN)
            // special case for -2^31 because 2^31 can't fit in a two's complement 32-bit integer
            return 12;
        sign = 1;
        num  = -num;
    }

    if (num < 1e5)
    {
        if (num < 1e3)
        {
            if (num < 10)
                return 1 + sign;
            else if (num < 1e2)
                return 2 + sign;
            else
                return 3 + sign;
        }
        else
        {
            if (num < 1e4)
                return 4 + sign;
            else
                return 5 + sign;
        }
    }
    else
    {
        if (num < 1e7)
        {
            if (num < 1e6)
                return 6 + sign;
            else
                return 7 + sign;
        }
        else
        {
            if (num < 1e8)
                return 8 + sign;
            else if (num < 1e9)
                return 9 + sign;
            else
                return 10 + sign;
        }
    }
}

/*
 * return the number of digits
 */
static inline int
digits64(int64 num)
{
    int sign = 0;
    if (num < 0)
    {
        if (num == LLONG_MIN)
            // special case for -2^63 because 2^63 can't fit in a two's complement 64-bit integer
            return 19;
        sign = 1;
        num  = -num;
    }

    if (num < 1e10)
    {
        if (num < 1e5)
        {
            if (num < 1e3)
            {
                if (num < 10)
                    return 1 + sign;
                else if (num < 1e2)
                    return 2 + sign;
                else
                    return 3 + sign;
            }
            else
            {
                if (num < 1e4)
                    return 4 + sign;
                else
                    return 5 + sign;
            }
        }
        else
        {
            if (num < 1e7)
            {
                if (num < 1e6)
                    return 6 + sign;
                else
                    return 7 + sign;
            }
            else
            {
                if (num < 1e8)
                    return 8 + sign;
                else if (num < 1e9)
                    return 9 + sign;
                else
                    return 10 + sign;
            }
        }
    }
    else
    {
        if (num < 1e15)
        {
            if (num < 1e12)
            {
                if (num < 1e11)
                    return 11 + sign;
                else
                    return 12 + sign;
            }
            else
            {
                if (num < 1e13)
                    return 13 + sign;
                else if (num < 1e14)
                    return 14 + sign;
                else
                    return 15 + sign;
            }
        }
        else
        {
            if (num < 1e17)
            {
                if (num < 1e16)
                    return 16 + sign;
                else
                    return 17 + sign;
            }
            else
            {
                if (num < 1e18)
                    return 18 + sign;
                else
                    return 19 + sign;
            }
        }
    }
}
#endif

#endif // ISTORE_H
