#include "istore.h"
#include "is_parser.h"

#include "access/htup_details.h"
#include "catalog/pg_type.h"
#include "funcapi.h"
#include "libpq/pqformat.h"
#include "utils/array.h"
#include "utils/builtins.h"
#include "utils/lsyscache.h"

${defines}

static inline Datum *store_key_val_datums(Store *is);

STORE_FUNCTION(out)
{
    Store        *in;
    int           i;
    StorePair    *pairs;
    StringInfoData s;

    in = PG_GETARG_STORE(0);

    if (in->len == 0)
        PG_RETURN_CSTRING(palloc0(1));

    pairs = FIRST_PAIR(in, StorePair);
    initStringInfo(&s);

    for (i = 0; i<in->len; ++i)
    {
        char *keystr = (char *) DirectFunctionCall1(key_output_func, KeyGetDatum(pairs[i].key)); 
        char *valstr = (char *) DirectFunctionCall1(val_output_func, ValueGetDatum(pairs[i].val)); 

        if (i > 0)
            appendStringInfo(&s, ", \"%s\"=>\"%s\"", keystr, valstr);
        else
            appendStringInfo(&s, "\"%s\"=>\"%s\"", keystr, valstr);
    }
    PG_RETURN_CSTRING(s.data);
}

STORE_FUNCTION(in)
{
    ISParser     parser = {
        .keyin = key_input_func,
        .valin = val_input_func,
        .keysize = KEYSIZE,
        .valsize = VALUESIZE};
    Store       *out;
    StorePairs  *pairs;
    AvlNode     *tree;
    int          n;

    parser.begin = PG_GETARG_CSTRING(0);

    if (parser.begin[0] == '\0')
    {
        EMPTY_ISTORE(out);
        PG_RETURN_POINTER(out);
    }

    tree = is_parse(&parser);

    pairs = palloc0(sizeof(StorePairs));
    n = is_tree_length(tree);
    store_pairs_init(pairs, n);
    store_tree_to_pairs(tree, pairs);
    istore_make_empty(tree);
    FINALIZE_STORE(out, pairs);
    PG_RETURN_POINTER(out);
}

STORE_FUNCTION(recv)
{
    Store *result;
    StringInfo buf = (StringInfo) PG_GETARG_POINTER(0);
    int i = 0;
    StorePairs *creator = palloc0(sizeof *creator);
    int32 len = pq_getmsgint(buf, 4);
    store_pairs_init(creator, len);
    for (; i < len; ++i)
    {
        Key key = BUF_READ_KEY(buf);
        StoreValue val = BUF_READ_VALUE(buf);
        store_pairs_insert(creator, key, val);
    }
    FINALIZE_STORE(result, creator);
    PG_RETURN_POINTER(result);
}

STORE_FUNCTION(send)
{
    Store *in = PG_GETARG_STORE(0);
    StorePair *pairs= FIRST_PAIR(in, StorePair);
    int i = 0;
    StringInfoData buf;
    pq_begintypsend(&buf);
    pq_sendint(&buf, in->len, 4);
    for (; i < in->len; ++i)
    {
        Key key = pairs[i].key;
        StoreValue val = pairs[i].val;
        BUF_STORE_KEY(&buf, key);
        BUF_STORE_VALUE(&buf, val);
    }
    PG_RETURN_BYTEA_P(pq_endtypsend(&buf));
}

STORE_FUNCTION(to_json)
{
    Store          *is = PG_GETARG_STORE(0);
    StorePair      *pairs;
    int             i;
    StringInfoData  dst;

    if (is->len == 0)
        PG_RETURN_TEXT_P(cstring_to_text_with_len("{}", 2));

    pairs   = FIRST_PAIR(is, StorePair);
    initStringInfo(&dst);
    appendStringInfoChar(&dst, '{');

    for (i = 0; i < is->len; i++)
    {
        appendStringInfoString(&dst, "\"");
        appendStringInfoString(&dst, (char *) DirectFunctionCall1(key_output_func, KeyGetDatum(pairs[i].key)));
        appendStringInfoString(&dst, "\": ");
        appendStringInfoString(&dst, (char *) DirectFunctionCall1(val_output_func, ValueGetDatum(pairs[i].val))); 
        if (i + 1 != is->len)
            appendStringInfoString(&dst, ", ");
    }
    appendStringInfoChar(&dst, '}');

    PG_RETURN_TEXT_P(cstring_to_text(dst.data));
}

/*
 * combine two Stores by applying PGFunction mergefunc on values where key match
 * if PGFunction miss1func is not NULL values for keys which doesn't exists on
 * first Store is added to the result by applying miss1func to the value
 * while values for keys which doesn't exists on second Store will be added without
 * change.
 * if PGFunction miss1func is NULL the result will only contain matching keys
 */
static Store *
store_merge(Store *arg1, Store *arg2, PGFunction mergefunc, PGFunction miss1func)
{
    Store      *result;
    StorePair  *pairs1, *pairs2;
    StorePairs *creator = NULL;
    int         index1 = 0, index2 = 0;

    pairs1  = FIRST_PAIR(arg1, StorePair);
    pairs2  = FIRST_PAIR(arg2, StorePair);
    creator = palloc0(sizeof *creator);

    store_pairs_init(creator, MIN(arg1->len + arg2->len, 200));

    while (index1 < arg1->len && index2 < arg2->len)
    {
        if (pairs1[index1].key < pairs2[index2].key)
        {
            if (miss1func != NULL)
                store_pairs_insert(creator, pairs1[index1].key, pairs1[index1].val);
            ++index1;
        }
        else if (pairs1[index1].key > pairs2[index2].key)
        {
            if (miss1func != NULL)
                store_pairs_insert(creator, pairs2[index2].key, DirectFunctionCall1(miss1func, pairs2[index2].val));
            ++index2;
        }
        else
        {
            if (mergefunc != NULL)
                store_pairs_insert(
                  creator, pairs1[index1].key, DirectFunctionCall2(mergefunc, pairs1[index1].val, pairs2[index2].val));
            else
                store_pairs_insert(creator, pairs1[index1].key, pairs2[index2].val);
            ++index1;
            ++index2;
        }
    }

    if (miss1func != NULL)
    {
        while (index1 < arg1->len)
        {
            store_pairs_insert(creator, pairs1[index1].key, pairs1[index1].val);
            ++index1;
        }

        while (index2 < arg2->len)
        {
            store_pairs_insert(creator, pairs2[index2].key, DirectFunctionCall1(miss1func, pairs2[index2].val));
            ++index2;
        }
    }

    FINALIZE_STORE(result, creator);

    return result;
}

/*
 * apply PGFunction applyfunc on each value of arg1 with arg2
 */
static Store *
store_apply_datum(Store *arg1, Datum arg2, PGFunction applyfunc)
{
    Store      *result;
    StorePair  *pairs;
    StorePairs *creator = NULL;
    int         index   = 0;

    pairs   = FIRST_PAIR(arg1, StorePair);
    creator = palloc0(sizeof *creator);

    store_pairs_init(creator, arg1->len);
    while (index < arg1->len)
    {
        store_pairs_insert(creator, pairs[index].key, DirectFunctionCall2(applyfunc, pairs[index].val, arg2));
        ++index;
    }
    FINALIZE_STORE(result, creator);

    return result;
}

/*
 * get the smallest key from an Store 
 */
STORE_FUNCTION(min_key)
{
    Store  *store;
    Key     key;

    store = PG_GETARG_STORE(0);
    if (store->len == 0) 
    {
        PG_RETURN_NULL();
    }
    else 
    {
        key = FIRST_PAIR(store, StorePair)[0].key;
        PG_RETURN_INT32(key);
    }
}

/*
 * get the biggest key from an Store
 */
STORE_FUNCTION(max_key)
{
    Store  *store;
    Key     key;

    store = PG_GETARG_STORE(0);
    if (store->len == 0) 
    {
        PG_RETURN_NULL();
    }
    else 
    {
        key = LAST_PAIR(store, StorePair)->key;
        PG_RETURN_INT32(key);
    }
}

/*
 * remove zero values from Store
 */
STORE_FUNCTION(compact)
{
    Store      *store, *result;
    StorePair  *pairs;
    int         index;
    StorePairs *creator;

    store   = PG_GETARG_STORE(0);
    pairs   = FIRST_PAIR(store, StorePair);
    index   = 0;
    creator = NULL;
    creator = palloc0(sizeof *creator);
    store_pairs_init(creator, store->len);
    while (index < store->len)
    {
        if (pairs[index].val != 0)
            store_pairs_insert(creator, pairs[index].key, pairs[index].val);
        ++index;
    }
    FINALIZE_STORE(result, creator);
    PG_RETURN_POINTER(result);
}

/*
 * Sum the values of a Store
 */
STORE_FUNCTION(sum_up)
{
    Store     *is;
    StorePair *pairs;
    int64      result;
    int        index;
    Key        end_key;

    is     = PG_GETARG_STORE(0);
    pairs  = FIRST_PAIR(is, StorePair);
    result = 0;
    index  = 0;

    if (is->len == 0)
        PG_RETURN_INT64(0);

    if (PG_NARGS() == 1)
    {
        while (index < is->len)
            result = DirectFunctionCall2(int8pl, result, pairs[index++].val);
    }
    else
    {
        end_key = PG_GETARG_KEY(1) > pairs[is->len - 1].key ? pairs[is->len - 1].key : PG_GETARG_KEY(1);
        while (index < is->len && pairs[index].key <= end_key)
            result = DirectFunctionCall2(int8pl, result, pairs[index++].val);
    }

    PG_RETURN_INT64(result);
}

/*
 * Binary search the key in the Store
 */
static StorePair *
store_find(Store *is, Key key, int *off_out)
{
    StorePair  *pairs  = FIRST_PAIR(is, StorePair);
    StorePair  *result = NULL;
    int         low    = 0;
    int         max    = is->len;
    int         mid    = 0;
    while (low < max)
    {
        mid = low + (max - low) / 2;
        if (key < pairs[mid].key)
            max = mid;
        else if (key > pairs[mid].key)
            low = mid + 1;
        else
        {
            result = FIRST_PAIR(is, StorePair) + mid;
            if (off_out)
                *off_out = mid;
            break;
        }
    }
    return result;
}

/*
 * Implementation of operator ?(Store, int)
 */
STORE_FUNCTION(exist)
{
    bool    found;
    Store  *in = PG_GETARG_STORE(0);
    Key     key = PG_GETARG_KEY(1);

    if (store_find(in, key, NULL))
        found = true;
    else
        found = false;
    PG_RETURN_BOOL(found);
}

/*
 * Implementation of operator ->(Store, int)
 */
STORE_FUNCTION(fetchval)
{
    StorePair  *pair;
    Store      *in  = PG_GETARG_STORE(0);
    Key         key = PG_GETARG_KEY(1);

    if ((pair = store_find(in, key, NULL)) == NULL)
        PG_RETURN_NULL();
    else
        PG_RETURN_INT64(pair->val);
}

/*
 * Merge two Stores by addition of values
 */
STORE_FUNCTION(add)
{
    Store *is1, *is2;

    is1 = PG_GETARG_STORE(0);
    is2 = PG_GETARG_STORE(1);

    PG_RETURN_POINTER(store_merge(is1, is2, plus_func, int8up));
}

/*
 * Increment values of a Store
 */
STORE_FUNCTION(add_integer)
{
    Store  *store;
    Datum   int_arg;

    store   = PG_GETARG_STORE(0);
    int_arg = PG_GETARG_DATUM(1);

    PG_RETURN_POINTER(store_apply_datum(store, int_arg, plus_func));
}

/*
 * Merge two Stores by subtracting
 *
 * Keys which doesn't exists on first Store is added to the results
 * a treated as if their value is zero
 */
STORE_FUNCTION(subtract)
{
    Store *is1, *is2;

    is1 = PG_GETARG_STORE(0);
    is2 = PG_GETARG_STORE(1);

    PG_RETURN_POINTER(store_merge(is1, is2, minus_func, int8um));
}

/*
 * Decrement values of a Store
 */
STORE_FUNCTION(subtract_integer)
{
    Store  *is;
    Datum   int_arg;

    is      = PG_GETARG_STORE(0);
    int_arg = PG_GETARG_DATUM(1);

    PG_RETURN_POINTER(store_apply_datum(is, int_arg, minus_func));
}

/*
 * Multiply values of two Stores
 *
 * The two Stores should have the same keys. The keys which exist on only
 * one Store are omitted.
 */
STORE_FUNCTION(multiply)
{
    Store *is1, *is2;

    is1 = PG_GETARG_STORE(0);
    is2 = PG_GETARG_STORE(1);

    PG_RETURN_POINTER(store_merge(is1, is2, mul_func, NULL));
}

/*
 * Multiply values of a Store
 */
STORE_FUNCTION(multiply_integer)
{
    Store  *is;
    Datum   int_arg;

    is      = PG_GETARG_STORE(0);
    int_arg = PG_GETARG_DATUM(1);

    PG_RETURN_POINTER(store_apply_datum(is, int_arg, mul_func));
}

/*
 * Divide values of two Stores
 *
 * The two Stores should have the same keys.  The keys which exist on only
 * one Store are omitted.
 */
STORE_FUNCTION(divide)
{
    Store *is1, *is2;

    is1 = PG_GETARG_STORE(0);
    is2 = PG_GETARG_STORE(1);

    PG_RETURN_POINTER(store_merge(is1, is2, div_func, NULL));
}

/*
 * Divide values of Store
 */
STORE_FUNCTION(divide_integer)
{
    Store  *is;
    Datum   int_arg;

    is      = PG_GETARG_STORE(0);
    int_arg = PG_GETARG_DATUM(1);

    PG_RETURN_POINTER(store_apply_datum(is, int_arg, div_func));
}

/*
 * concat two Stores
 *
 * duplicate keys get overwritten
 */
STORE_FUNCTION(concat)
{
    Store *is1, *is2;

    is1 = PG_GETARG_STORE(0);
    is2 = PG_GETARG_STORE(1);

    PG_RETURN_POINTER(store_merge(is1, is2, NULL, int8up));
}

/*
 * create a Store from an intarray by counting elements
 */
STORE_FUNCTION(from_intarray)
{
    Store      *result;
    Datum      *i_data;
    bool       *nulls;
    int         n, s = 0;
    int16       i_typlen;
    bool        i_typbyval;
    char        i_typalign;
    Oid         i_eltype;
    AvlNode    *tree;
    StorePairs *pairs;
    AvlNode    *position;
    Key         key;
    int         i;

    ArrayType *input = PG_GETARG_ARRAYTYPE_P(0);
    if (input == NULL)
        PG_RETURN_NULL();

    i_eltype = ARR_ELEMTYPE(input);

    get_typlenbyvalalign(i_eltype, &i_typlen, &i_typbyval, &i_typalign);

    deconstruct_array(input, i_eltype, i_typlen, i_typbyval, i_typalign, &i_data, &nulls, &n);

    tree = NULL;

    for (i = 0; i < n; ++i)
    {
        if (nulls[i])
            continue;
        switch (i_eltype)
        {
            case INT2OID: key = DatumGetInt16(i_data[i]); break;
            case INT4OID: key = DatumGetInt32(i_data[i]); break;
            /* TODO: 64bit case */
            default: elog(ERROR, "unsupported array type");
        }

        position = is_tree_find(key, tree);
        if (position == NULL)
        {
            tree = is_tree_insert(tree, key, 1);
            ++s;
        }
        else
            // overflow is unlikely as you'd hit the 1GB limit before
            position->value += 1;
    }

    pairs = palloc0(sizeof *pairs);
    store_pairs_init(pairs, s);
    store_tree_to_pairs(tree, pairs);
    istore_make_empty(tree);

    FINALIZE_STORE(result, pairs);
    PG_RETURN_POINTER(result);
}

/*
 * Store from key and value intarrays
 * bot arrays must have the same length, NULLs are omitted
 * duplicate keys result in added values
 */
static Datum
store_add_from_int_arrays(ArrayType *input1, ArrayType *input2)
{
    Store       *out;
    Datum       *i_data1, *i_data2;
    bool        *nulls1, *nulls2;
    StorePairs  *pairs;
    int          i, n = 0, n1, n2;
    int16        i_typlen1, i_typlen2;
    bool         i_typbyval1, i_typbyval2;
    char         i_typalign1, i_typalign2;
    Oid          i_eltype1, i_eltype2;
    AvlNode     *tree;
    AvlNode     *position;
    Key          key;
    StoreValue   value;

    i_eltype1 = ARR_ELEMTYPE(input1);
    i_eltype2 = ARR_ELEMTYPE(input2);

    get_typlenbyvalalign(i_eltype1, &i_typlen1, &i_typbyval1, &i_typalign1);

    get_typlenbyvalalign(i_eltype2, &i_typlen2, &i_typbyval2, &i_typalign2);

    deconstruct_array(input1, i_eltype1, i_typlen1, i_typbyval1, i_typalign1, &i_data1, &nulls1, &n1);

    deconstruct_array(input2, i_eltype2, i_typlen2, i_typbyval2, i_typalign2, &i_data2, &nulls2, &n2);

    if (n1 != n2)
        elog(ERROR, "array dont have the same length");

    tree = NULL;

    for (i = 0; i < n1; ++i)
    {
        if (nulls1[i] || nulls2[i])
            continue;

        switch (i_eltype1)
        {
            case INT2OID: key = DatumGetInt16(i_data1[i]); break;
            case INT4OID: key = DatumGetInt32(i_data1[i]); break;
            case INT8OID: key = DatumGetInt64(i_data2[i]); break;
            default: elog(ERROR, "unsupported array type");
        }
        switch (i_eltype2)
        {
            case INT2OID: value = DatumGetInt16(i_data2[i]); break;
            case INT4OID: value = DatumGetInt32(i_data2[i]); break;
            case INT8OID: value = DatumGetInt64(i_data2[i]); break;
            default: elog(ERROR, "unsupported array type");
        }

        position = is_tree_find(key, tree);

        if (position == NULL)
        {
            tree = is_tree_insert(tree, key, value);
            ++n;
        }
        else
            position->value = DirectFunctionCall2(plus_func, position->value, value);
    }

    pairs = palloc0(sizeof *pairs);
    store_pairs_init(pairs, n);
    store_tree_to_pairs(tree, pairs);
    istore_make_empty(tree);

    FINALIZE_STORE(out, pairs);
    PG_RETURN_POINTER(out);
}

/*
 * Store from key and value intarrays
 */
STORE_FUNCTION(array_add)
{
    Datum      result;
    ArrayType *input1, *input2;

    if (PG_ARGISNULL(0) || PG_ARGISNULL(1))
        PG_RETURN_NULL();

    input1 = PG_GETARG_ARRAYTYPE_P(0);
    input2 = PG_GETARG_ARRAYTYPE_P(1);
    result = store_add_from_int_arrays(input1, input2);
    if (result == 0)
        PG_RETURN_NULL();

    return result;
}

/*
 * Common initialization function for the various set-returning
 * funcs. fcinfo is only passed if the function is to return a
 * composite; it will be used to look up the return tupledesc.
 * we stash a copy of the Store in the multi-call context in
 * case it was originally toasted.
 */
static void
setup_firstcall(FuncCallContext *funcctx, Store *is, FunctionCallInfoData *fcinfo)
{
    MemoryContext oldcontext;
    Store *   st;

    oldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);

    st = palloc0(ISTORE_SIZE(is, StorePair));
    memcpy(st, is, ISTORE_SIZE(is, StorePair));

    funcctx->user_fctx = (void *) st;

    if (fcinfo)
    {
        TupleDesc tupdesc;

        /* Build a tuple descriptor for our result type */
        if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)
            elog(ERROR, "return type must be a row type");

        funcctx->tuple_desc = BlessTupleDesc(tupdesc);
    }

    MemoryContextSwitchTo(oldcontext);
}

/*
 * return keys and values as a set
 */
STORE_FUNCTION(each)
{
    FuncCallContext *funcctx;
    Store *      is;
    int              i;
    StorePair *  pairs;

    if (SRF_IS_FIRSTCALL())
    {
        is      = PG_GETARG_STORE(0);
        funcctx = SRF_FIRSTCALL_INIT();
        setup_firstcall(funcctx, is, fcinfo);
    }

    funcctx = SRF_PERCALL_SETUP();
    is      = (Store *) funcctx->user_fctx;
    i       = funcctx->call_cntr;
    pairs   = FIRST_PAIR(is, StorePair);

    if (i < is->len)
    {
        Datum     res, dvalues[2];
        bool      nulls[2] = { false, false };
        HeapTuple tuple;

        dvalues[0] = Int32GetDatum(pairs[i].key);
        dvalues[1] = Int64GetDatum(pairs[i].val);
        tuple      = heap_form_tuple(funcctx->tuple_desc, dvalues, nulls);
        res        = HeapTupleGetDatum(tuple);

        SRF_RETURN_NEXT(funcctx, PointerGetDatum(res));
    }

    SRF_RETURN_DONE(funcctx);
}

/*
 * fill missing keys in a range
 */
STORE_FUNCTION(fill_gaps)
{

    Store *    is, *result;
    StorePair *pairs;

    StorePairs *creator = NULL;

    int up_to, fill_with, index1 = 0, index2 = 0;

    if (PG_ARGISNULL(0))
        PG_RETURN_NULL();

    is    = PG_GETARG_STORE(0);
    up_to = PG_GETARG_INT32(1);

    fill_with = PG_GETARG_VALUE(2);
    pairs     = FIRST_PAIR(is, StorePair);
    creator   = palloc0(sizeof *creator);

    if (up_to < 0)
        elog(ERROR, "parameter upto must be >= 0");

    store_pairs_init(creator, up_to + 1);

    for (index1 = 0; index1 <= up_to; ++index1)
    {
        if (index2 < is->len && index1 == pairs[index2].key)
        {
            store_pairs_insert(creator, pairs[index2].key, pairs[index2].val);
            ++index2;
        }
        else
        {
            store_pairs_insert(creator, index1, fill_with);
        }
    }

    FINALIZE_STORE(result, creator);
    PG_RETURN_POINTER(result);
}

/*
 * rolling sum over keys
 */
STORE_FUNCTION(accumulate)
{

    Store      *is, *result;
    StorePair  *pairs;
    StorePairs *creator = NULL;
    int         index1 = 0, index2 = 0;
    size_t      size = 0;
    Key         start_key = 0, end_key = -1;
    int64       sum = 0;

    if (PG_ARGISNULL(0))
        PG_RETURN_NULL();

    is = PG_GETARG_STORE(0);

    pairs   = FIRST_PAIR(is, StorePair);
    creator = palloc0(sizeof *creator);

    if (is->len > 0)
    {
        start_key = pairs[0].key;
        end_key   = PG_NARGS() == 1 ? pairs[is->len - 1].key : PG_GETARG_KEY(1);
        size      = start_key > end_key ? 0 : (end_key - start_key + 1);
    }

    store_pairs_init(creator, size);

    for (index1 = start_key; index1 <= end_key; ++index1)
    {
        if (index2 < is->len && index1 == pairs[index2].key)
        {

            sum = DirectFunctionCall2(plus_func, sum, pairs[index2].val);
            ++index2;
        }
        store_pairs_insert(creator, index1, sum);
    }

    FINALIZE_STORE(result, creator);
    PG_RETURN_POINTER(result);
}

/*
 * construct a Store with a key range and a fixed value
 */
STORE_FUNCTION(seed)
{

    Store      *result;
    StorePairs *creator = NULL;
    Key         from, up_to;
    StoreValue  fill_with;
    Key         index1 = 0;

    if (PG_ARGISNULL(0) || PG_ARGISNULL(1))
        PG_RETURN_NULL();

    from      = PG_GETARG_KEY(0);
    up_to     = PG_GETARG_KEY(1);
    fill_with = PG_GETARG_VALUE(2);
    creator   = palloc0(sizeof *creator);

    if (up_to < from)
        elog(ERROR, "parameter upto must be >= from");

    if (from < 0)
        elog(ERROR, "parameter from must be >= 0");

    store_pairs_init(creator, up_to - from + 1);

    for (index1 = from; index1 <= up_to; ++index1)
    {
        store_pairs_insert(creator, index1, fill_with);
    }

    FINALIZE_STORE(result, creator);
    PG_RETURN_POINTER(result);
}

/*
 * Merge two Stores by extraccting the bigger values
 */
STORE_FUNCTION(val_larger)
{
    Store *is1, *is2;

    is1 = PG_GETARG_STORE(0);
    is2 = PG_GETARG_STORE(1);

    PG_RETURN_POINTER(store_merge(is1, is2, int8larger, int8up));
}

/*
 * Merge two Stores by extraccting the smaller values
 */
STORE_FUNCTION(val_smaller)
{
    Store *is1, *is2;

    is1 = PG_GETARG_STORE(0);
    is2 = PG_GETARG_STORE(1);

    PG_RETURN_POINTER(store_merge(is1, is2, int8smaller, int8up));
}

/*
 * return array of keys
 */
STORE_FUNCTION(akeys)
{
    Store      *is;
    StorePair  *pairs;
    Datum      *d;
    ArrayType  *a;
    int         index;

    is    = PG_GETARG_STORE(0);
    index = 0;

    if (is->len == 0)
    {
        a = construct_empty_array(KEYOID);
        PG_RETURN_POINTER(a);
    }

    pairs = FIRST_PAIR(is, StorePair);
    d     = (Datum *) palloc(sizeof(Datum) * is->len);

    while (index < is->len)
    {
        d[index] = pairs[index].key;
        ++index;
    }

    a = construct_array(d, is->len, KEYOID, sizeof(Key), true, 'i');
    PG_RETURN_POINTER(a);
}

/*
 * return array of values
 */
STORE_FUNCTION(avals)
{
    Store      *is;
    StorePair  *pairs;
    Datum      *d;
    ArrayType  *a;
    int         index;

    is    = PG_GETARG_STORE(0);
    index = 0;

    if (is->len == 0)
    {
        a = construct_empty_array(VALUEOID);
        PG_RETURN_POINTER(a);
    }

    pairs = FIRST_PAIR(is, StorePair);
    d     = (Datum *) palloc(sizeof(Datum) * is->len);

    while (index < is->len)
    {
        d[index] = pairs[index].val;
        ++index;
    }

    /* TODO: Use FLOAT8PASSBYVAL depending on value size */
    a = construct_array(d, is->len, VALUEOID, sizeof(StoreValue), FLOAT8PASSBYVAL, VALUE_ALIGN);
    PG_RETURN_POINTER(a);
}

/*
 * return set of keys
 */
STORE_FUNCTION(skeys)
{
    Store           *is;
    FuncCallContext *funcctx;
    StorePair       *pairs;
    int              i;

    if (SRF_IS_FIRSTCALL())
    {
        is      = PG_GETARG_STORE(0);
        funcctx = SRF_FIRSTCALL_INIT();
        setup_firstcall(funcctx, is, NULL);
    }

    funcctx = SRF_PERCALL_SETUP();
    is      = (Store *) funcctx->user_fctx;
    i       = funcctx->call_cntr;
    pairs   = FIRST_PAIR(is, StorePair);

    if (i < is->len)
        SRF_RETURN_NEXT(funcctx, KeyGetDatum(pairs[i].key));

    SRF_RETURN_DONE(funcctx);
}

/*
 * return set of values
 */
STORE_FUNCTION(svals)
{
    Store      *is;
    FuncCallContext *funcctx;
    StorePair  *pairs;
    int         i;

    if (SRF_IS_FIRSTCALL())
    {
        is      = PG_GETARG_STORE(0);
        funcctx = SRF_FIRSTCALL_INIT();
        setup_firstcall(funcctx, is, NULL);
    }

    funcctx = SRF_PERCALL_SETUP();
    is      = (Store *) funcctx->user_fctx;
    i       = funcctx->call_cntr;
    pairs   = FIRST_PAIR(is, StorePair);

    if (i < is->len)
        SRF_RETURN_NEXT(funcctx, ValueGetDatum(pairs[i].val));

    SRF_RETURN_DONE(funcctx);
}

STORE_FUNCTION(length)
{
    const Store *is = PG_GETARG_STORE(0);
    PG_RETURN_INT32(is->len);
}

/*
 * return palloced array of alternating key values
 * returns NULL if Store is empty
 */
static inline Datum *
store_key_val_datums(Store *is)
{
    Datum      *d;
    StorePair  *pairs;
    int         index = 0;

    if (is->len == 0)
        return NULL;

    pairs = FIRST_PAIR(is, StorePair);
    d     = (Datum *) palloc(sizeof(Datum) * is->len * 2);

    while (index < is->len)
    {
        d[index * 2]     = pairs[index].key;
        d[index * 2 + 1] = pairs[index].val;
        ++index;
    }
    return d;
}

STORE_FUNCTION(to_array)
{
    Store      *is;
    ArrayType  *a;
    Datum      *d;

    is = PG_GETARG_STORE(0);

    if (is->len == 0)
    {
        a = construct_empty_array(VALUEOID);
        PG_RETURN_POINTER(a);
    }

    d = store_key_val_datums(is);
    a = construct_array(d, is->len * 2, VALUEOID, sizeof(StoreValue), true, 'i');
    PG_RETURN_POINTER(a);
}

STORE_FUNCTION(to_matrix)
{
    Store *is;
    Datum *    d;
    ArrayType *a;
    int        out_size[2] = { 0, 2 };
    int        lb[2]       = { 1, 1 };

    is = PG_GETARG_STORE(0);

    if (is->len == 0)
    {
        a = construct_empty_array(VALUEOID);
        PG_RETURN_POINTER(a);
    }

    out_size[0] = is->len;
    d           = store_key_val_datums(is);
    a           = construct_md_array(d, NULL, 2, out_size, lb, VALUEOID, sizeof(StoreValue), true, 'i');
    PG_RETURN_POINTER(a);
}

STORE_FUNCTION(slice)
{
    StorePair  *pairs;
    Store      *result;
    Store      *is      = PG_GETARG_STORE(0);
    StorePairs *creator = NULL;
    ArrayType  *a       = PG_GETARG_ARRAYTYPE_P_COPY(1);
    Key        *ar      = (Key *) ARR_DATA_PTR(a);
    int         alen    = ArrayGetNItems(ARR_NDIM(a), ARR_DIMS(a));
    int         index1  = 0,
                index2  = 0;
    bool        found   = false;

    if (ARR_HASNULL(a) && array_contains_nulls(a))
        ereport(ERROR, (errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED), errmsg("array must not contain nulls")));

    pairs   = FIRST_PAIR(is, StorePair);
    creator = palloc0(sizeof *creator);

    store_pairs_init(creator, MIN(is->len, alen));

    if (alen > 1)
        qsort((void *) ar, alen, sizeof(Key), key_cmp);

    while (index1 < is->len && index2 < alen)
    {
        if (pairs[index1].key < ar[index2])
        {
            ++index1;
        }
        else if (pairs[index1].key > ar[index2])
        {
            ++index2;
        }
        else
        {
            store_pairs_insert(creator, pairs[index1].key, pairs[index1].val);
            ++index1;
            ++index2;
            found = true;
        }
    }
    if (found)
    {
        FINALIZE_STORE(result, creator);
        PG_RETURN_POINTER(result);
    }
    else
        PG_RETURN_NULL();
}

STORE_FUNCTION(slice_to_array)
{
    StorePair     *pair;
    Store         *is   = PG_GETARG_STORE(0);
    ArrayType     *a    = PG_GETARG_ARRAYTYPE_P(1);
    int32 *        ar   = (int32 *) ARR_DATA_PTR(a);
    int            alen = ArrayGetNItems(ARR_NDIM(a), ARR_DIMS(a));
    int            lbs[1];
    int            dims[1];
    int            i;
    Datum *        out_datums;
    bool *         out_nulls;
    ArrayType *    aout;

    if (ARR_HASNULL(a) && array_contains_nulls(a))
        ereport(ERROR, (errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED), errmsg("array must not contain nulls")));

    out_datums = palloc(sizeof(Datum) * alen);
    out_nulls  = palloc(sizeof(bool) * alen);
    dims[0]    = alen;
    lbs[0]     = 1;

    for (i = 0; i < alen; ++i)
    {
        if ((pair = store_find(is, ar[i], NULL)) == NULL)
        {
            out_datums[i] = (Datum) 0;
            out_nulls[i]  = true;
        }
        else
        {
            out_datums[i] = pair->val;
            out_nulls[i]  = false;
        }
    }

    aout = construct_md_array(out_datums, out_nulls, 1, dims, lbs, INT8OID, sizeof(int64), true, 'i');

    PG_RETURN_POINTER(aout);
}

static Store *
store_clamp_pass(Store * is, Key clamp_key, int delta_dir)
{
    Store      *result_is;
    StorePair  *pairs;
    StorePairs  creator;
    StoreValue  clamp_sum = 0;
    int         index = 0, count = 0, delta_buflen = 0;

    /* short circuit out of the funciton if there is nothing to clamp */
    if(delta_dir > 0 && FIRST_PAIR(is, StorePair)->key >= clamp_key)
        return is;
    if(delta_dir < 0 && LAST_PAIR(is, StorePair)->key <= clamp_key) 
        return is;

    pairs = FIRST_PAIR(is, StorePair);
    index = delta_dir > 0 ? 0 : is->len - 1;
    while ( ((delta_dir > 0) && (index < is->len && pairs[index].key <= clamp_key)) ||
            ((delta_dir < 0) && (index >= 0      && pairs[index].key >= clamp_key)) )
    {
        INTPL(pairs[index].val, clamp_sum, clamp_sum);
        //delta_buflen += store_pair_buf_len(pairs + index);
        index += delta_dir, count++;
    }

    /* back to the last element that is to be clamped */
    index -= delta_dir, count--;

    /* copy survivors into a new spot */
    if (delta_dir > 0)
        pairs = pairs + index;

    creator = (StorePairs) {
        .pairs  = pairs,
        .buflen = is->buflen - delta_buflen,
        .used   = is->len - count
    };
    FINALIZE_ISTORE_BASE(result_is, (&creator), StorePair);

    /* put the clamp_sum in the clamp-key place */
    pairs = delta_dir > 0 ? FIRST_PAIR(result_is, StorePair) : LAST_PAIR(result_is, StorePair);
    pairs->key = clamp_key;
    pairs->val = clamp_sum;
    //result_is->buflen += store_pair_buf_len(pairs);

    return result_is;
}

STORE_FUNCTION(clamp_below)
{
    PG_RETURN_POINTER(store_clamp_pass(PG_GETARG_STORE(0), PG_GETARG_KEY(1), 1));
}

STORE_FUNCTION(clamp_above)
{
    PG_RETURN_POINTER(store_clamp_pass(PG_GETARG_STORE(0), PG_GETARG_KEY(1), -1));
}

STORE_FUNCTION(delete)
{
    StorePair *pair;
    Store *    is  = PG_GETARG_STORE_COPY(0);
    Key        key = PG_GETARG_KEY(1);
    int        del_off;

    if ((pair = store_find(is, key, &del_off)))
    {
        --is->len;
        //is->buflen -= store_pair_buf_len(pair);
        if (is->len > del_off)
            memmove(pair, pair + 1, (is->len - del_off) * sizeof(StorePair));
    }
    SET_VARSIZE(is, ISHDRSZ + (is->len * sizeof(StorePair)));
    PG_RETURN_POINTER(is);
}

STORE_FUNCTION(delete_array)
{
    StorePair *pairs;
    Store     *is       = PG_GETARG_STORE_COPY(0);
    ArrayType *a        = PG_GETARG_ARRAYTYPE_P_COPY(1);
    Key       *ar       = (Key *) ARR_DATA_PTR(a);
    int        alen     = ArrayGetNItems(ARR_NDIM(a), ARR_DIMS(a));
    int        is_index = 0, ar_index = 0;

    if (ARR_HASNULL(a) && array_contains_nulls(a))
        ereport(ERROR, (errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED), errmsg("array must not contain nulls")));

    pairs = FIRST_PAIR(is, StorePair);

    if (alen > 1)
        qsort((void *) ar, alen, sizeof(Key), key_cmp);

    while (is_index < is->len && ar_index < alen)
    {
        if (pairs[is_index].key < ar[ar_index])
        {
            ++is_index;
        }
        else if (pairs[is_index].key > ar[ar_index])
        {
            ++ar_index;
        }
        else
        {
            --is->len;
            //is->buflen -= store_pair_buf_len(pairs + is_index);
            if (is->len > is_index)
                memmove(pairs + is_index, pairs + is_index + 1, (is->len - is_index) * sizeof(StorePair));

            ++ar_index;
        }
    }

    SET_VARSIZE(is, ISHDRSZ + (is->len * sizeof(StorePair)));
    PG_RETURN_POINTER(is);
}

STORE_FUNCTION(delete_istore)
{
    StorePair *pairs, *delpairs;
    Store     *is    = PG_GETARG_STORE_COPY(0);
    Store     *isdel = PG_GETARG_STORE(1);

    int index1 = 0, index2 = 0;

    pairs    = FIRST_PAIR(is, StorePair);
    delpairs = FIRST_PAIR(isdel, StorePair);

    while (index1 < is->len && index2 < isdel->len)
    {
        if (pairs[index1].key < delpairs[index2].key)
        {
            ++index1;
        }
        else if (pairs[index1].key > delpairs[index2].key)
        {
            ++index2;
        }
        else
        {
            if (pairs[index1].val == delpairs[index2].val)
            {
                --is->len;
                //is->buflen -= store_pair_buf_len(pairs + index1);
                if (is->len > index1)
                    memmove(pairs + index1, pairs + index1 + 1, (is->len - index1) * sizeof(StorePair));
                ++index2;
            }
            else
            {
                ++index2;
                ++index1;
            }
        }
    }

    SET_VARSIZE(is, ISHDRSZ + (is->len * sizeof(StorePair)));
    PG_RETURN_POINTER(is);
}

STORE_FUNCTION(exists_any)
{
    Store     *is   = PG_GETARG_STORE(0);
    ArrayType *a    = PG_GETARG_ARRAYTYPE_P(1);
    Key       *ar   = (Key *) ARR_DATA_PTR(a);
    int        alen = ArrayGetNItems(ARR_NDIM(a), ARR_DIMS(a));
    int        i    = 0;

    if (ARR_HASNULL(a) && array_contains_nulls(a))
        ereport(ERROR, (errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED), errmsg("array must not contain nulls")));

    for (i = 0; i < alen; i++)
    {
        if (store_find(is, ar[i], NULL) != NULL)
            PG_RETURN_BOOL(true);
    }

    PG_RETURN_BOOL(false);
}

STORE_FUNCTION(exists_all)
{
    Store     *is   = PG_GETARG_STORE(0);
    ArrayType *a    = PG_GETARG_ARRAYTYPE_P(1);
    Key       *ar   = (Key *) ARR_DATA_PTR(a);
    int        alen = ArrayGetNItems(ARR_NDIM(a), ARR_DIMS(a));
    int        i;

    if (ARR_HASNULL(a) && array_contains_nulls(a))
        ereport(ERROR, (errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED), errmsg("array must not contain nulls")));

    for (i = 0; i < alen; i++)
    {
        if (store_find(is, ar[i], NULL) == NULL)
            PG_RETURN_BOOL(false);
    }

    PG_RETURN_BOOL(true);
}


/*
 * Aggregation
 */

#define INITSTATESIZE 30

#define INIT_AGG_STATE(_state)                                                                   \
    do {                                                                                         \
        MemoryContext  agg_context;                                                              \
                                                                                                 \
        if (!AggCheckCallContext(fcinfo, &agg_context))                                          \
            elog(ERROR, "aggregate function called in non-aggregate context");                   \
                                                                                                 \
        if (PG_ARGISNULL(1) && PG_ARGISNULL(0)) PG_RETURN_NULL();                                \
                                                                                                 \
        _state = PG_ARGISNULL(0) ? state_init(agg_context) : (ISAggState *) PG_GETARG_POINTER(0);\
                                                                                                 \
        if (PG_ARGISNULL(1)) PG_RETURN_POINTER(_state);                                          \
                                                                                                 \
    } while(0)

typedef struct
{
    int64 key;
    int64 val;
} StatePair;

typedef struct {
    size_t size;
    int    used;
    StatePair pairs[0];  /* TODO: Use some generic type */
} ISAggState;

typedef enum {
    AGG_SUM,
    AGG_MIN,
    AGG_MAX
} ISAggType;

static inline ISAggState *
state_init(MemoryContext agg_context)
{
    ISAggState *state;
    state = (ISAggState *) MemoryContextAllocZero(agg_context, sizeof(ISAggState) + INITSTATESIZE * sizeof(StatePair));
    state->size = INITSTATESIZE;
    return state;
}

static inline ISAggState *
store_agg_internal(ISAggState *state, Store *istore, ISAggType type)
{
    StatePair  *pairs1;
    StorePair  *pairs2;
    int         index1 = 0,
                index2 = 0;

    pairs1 = state->pairs;
    pairs2 = FIRST_PAIR(istore, StorePair);
    while (index1 < state->used && index2 < istore->len)
    {
        if (pairs1->key < pairs2->key)
        {
            // do nothing keep state
            ++pairs1;
            ++index1;
        }
        else if (pairs1->key > pairs2->key)
        {
            int j;
            int i = 1;
            while(index2 + i < istore->len && pairs1->key > pairs2[i].key){
                ++i;
            }

            // ensure array is big enough
            if (state->size < state->used + i)
            {
                state->size  = state->size * 2 > state->used + i ? state->size * 2 : state->used + i;
                state        = repalloc(state, sizeof(ISAggState) + state->size * sizeof(StatePair));
                pairs1       = state->pairs+index1;
            }

            // move data i steps forward from index1
            memmove(pairs1 + i, pairs1, (state->used - index1) * sizeof(StatePair));

            // copy data
            state->used += i;

            /* TODO: Use memcpy if pairs1 and pairs2 are of same size */
            for (j = 0; j < i; j++)
            {
                pairs1->key = pairs2->key;
                pairs1->val = pairs2->val;
                ++pairs1;
                ++pairs2;
            }
            index1 += i;
            index2 += i;
        }
        else
        {
            // identical keys - apply logic according to aggregation type
            if (type == AGG_SUM)
            {
                    /*
                    * Overflow check.  If the inputs are of different signs then their sum
                    * cannot overflow.  If the inputs are of the same sign, their sum had
                    * better be that sign too.
                    */
                    if (SAMESIGN(pairs1->val, pairs2->val))
                    {
                        pairs1->val += pairs2->val;
                        if(!SAMESIGN(pairs1->val, pairs2->val))
                            ereport(ERROR,
                                    (errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),
                                    errmsg("bigint out of range")));
                    }
                    else
                    {
                        pairs1->val += pairs2->val;
                    }
            }
            else if (type == AGG_MIN)
            {
                pairs1->val = MIN(pairs2->val, pairs1->val);
            }
            else if (type == AGG_MAX)
            {
                pairs1->val = MAX(pairs2->val, pairs1->val);
            }

            ++index1;
            ++index2;
            ++pairs1;
            ++pairs2;
        }
    }

    // append any leftovers
    int i = istore->len - index2;
    if ( i > 0 )
    {
        if (state->size <= state->used + i)
        {
            state->size = state->size * 2 > state->used + i ? state->size * 2 : state->used + i;
            state       = repalloc(state, sizeof(ISAggState) + state->size * sizeof(StatePair));
            pairs1      = state->pairs + index1;
        }
        state->used += i;

        /* TODO: Use memcpy if pairs1 and pairs2 are of same size */
        for (int j=0; j<i; j++)
        {
            pairs1->key = pairs2->key;
            pairs1->val = pairs2->val;
            ++pairs1;
            ++pairs2;
        }
    }

    return state;
}

/*
 * MIN(istore) aggregate funtion
 */
STORE_FUNCTION(min_transfn)
{
    ISAggState    *state;
    INIT_AGG_STATE(state);

    PG_RETURN_POINTER(store_agg_internal(state, PG_GETARG_STORE(1), AGG_MIN));
}

/*
 * MAX(istore) aggregate funtion
 */
STORE_FUNCTION(max_transfn)
{
    ISAggState    *state;
    INIT_AGG_STATE(state);

    PG_RETURN_POINTER(store_agg_internal(state, PG_GETARG_STORE(1), AGG_MAX));
}

/*
 * SUM(istore) aggregate funtion
 */
STORE_FUNCTION(sum_transfn)
{
    ISAggState    *state;
    INIT_AGG_STATE(state);

    PG_RETURN_POINTER(store_agg_internal(state, PG_GETARG_STORE(1), AGG_SUM));
}

/*
 * Final function for SUM(istore/bigistore) and MIN/MAX(bigistore)
 * Both SUM transition functions return the same transition type - the same as
 * MIN/MAX(bigistore).
 */
STORE_FUNCTION(agg_finalfn_pairs)
{
    ISAggState  *state;
    Store       *istore;
    IStorePair *istore_pairs;

    if (PG_ARGISNULL(0)) PG_RETURN_NULL();

    state       = (ISAggState *) PG_GETARG_POINTER(0);
    istore      = (Store *) palloc0(ISHDRSZ + state->used * sizeof(StorePair));
    istore->len = state->used;

    /* TODO: Probably use memcpy if pairs are of same size */
    istore_pairs = FIRST_PAIR(istore, IStorePair);
    for (int i = 0; i < istore->len; ++i)
    {
        istore_pairs[i].key = state->pairs[i].key;
        istore_pairs[i].val = state->pairs[i].val;
        /* TODO: estimate buflen for custom type key */
        //istore->buflen += keydigits(istore_pairs[i].key) + valdigits(istore_pairs[i].val) + BUFLEN_OFFSET;
    }

    //if (istore->buflen < 0)
    //    elog(ERROR, "istore buffer overflow");

    SET_VARSIZE(istore, ISHDRSZ + state->used * sizeof(StorePair));

    PG_RETURN_POINTER(istore);
}

/*
 * Agg(int, bigint) aggregate funtion
 */
STORE_FUNCTION(avl_transfn)
{
    AvlNode         *tree;
    AvlNode         *position;
    MemoryContext    agg_context, oldcontext;
    Key              key;
    StoreValue       value, pl_result;

    if (!AggCheckCallContext(fcinfo, &agg_context))
        elog(ERROR, "aggregate function called in non-aggregate context");

    if (PG_ARGISNULL(0) && (PG_ARGISNULL(1) || PG_ARGISNULL(2)))
        PG_RETURN_NULL();

    tree  = PG_ARGISNULL(0) ? NULL : (AvlNode *) PG_GETARG_POINTER(0);

    if (PG_ARGISNULL(1) || PG_ARGISNULL(2))
        PG_RETURN_POINTER(tree);

    key         = PG_GETARG_KEY(1);
    value       = PG_GETARG_VALUE(2);
    oldcontext  = MemoryContextSwitchTo(agg_context);
    position    = is_tree_find(key, tree);

    if (position == NULL)
        tree = is_tree_insert(tree, key, value);
    else
    {
        INTPL(position->value, value, pl_result);
        position->value = pl_result;
    }
    MemoryContextSwitchTo(oldcontext);
    PG_RETURN_POINTER(tree);
}

STORE_FUNCTION(avl_finalfn)
{
    AvlNode     *tree;
    Store       *istore;
    StorePairs  *pairs;

    if (PG_ARGISNULL(0)) PG_RETURN_NULL();

    tree  = (AvlNode *) PG_GETARG_POINTER(0);

    pairs = palloc0(sizeof *pairs);
    store_pairs_init(pairs, 200);
    store_tree_to_pairs(tree, pairs);
    istore_make_empty(tree);

    FINALIZE_STORE(istore, pairs);
    PG_RETURN_POINTER(istore);
}
