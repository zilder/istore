/*
 * input and output functions for istore
 */

#include "istore.h"
#include "is_parser.h"
#include "libpq/pqformat.h"
#include "fmgr.h"
#include "utils/builtins.h"
{%


/*
 * ${store} IO routines
 */

#define Store ${store}
#define StorePair ${store}Pair
#define StorePairs ${store}Pairs
#define Key int${keybits}
#define Val int${valbits}
#define KeyGetDatum Int${keybits}GetDatum
#define ValueGetDatum Int${valbits}GetDatum
#define PG_GETARG_STORE PG_GETARG_${store_upper}

/*
 * Declare in and out functions. They should be defined somewhere else (in
 * PostgreSQL itself or in extension's shared library)
 */
Datum ${keyout}(PG_FUNCTION_ARGS);
Datum ${keyin}(PG_FUNCTION_ARGS);

PG_FUNCTION_INFO_V1(${store_lower}_out);
Datum
${store_lower}_out(PG_FUNCTION_ARGS)
{
    Store     *in;
    int        i;
    StorePair *pairs;
    StringInfoData s;

    in = PG_GETARG_STORE(0);

    if (in->len == 0)
        PG_RETURN_CSTRING(palloc0(1));

    pairs = FIRST_PAIR(in, StorePair);
    initStringInfo(&s);

    for (i = 0; i<in->len; ++i)
    {
        char *keystr = (char *) DirectFunctionCall1(${keyout}, KeyGetDatum(pairs[i].key)); 
        char *valstr = (char *) DirectFunctionCall1(int${valsize}out, ValueGetDatum(pairs[i].val)); 

        if (i > 0)
            appendStringInfo(&s, ", \"%s\"=>\"%s\"", keystr, valstr);
        else
            appendStringInfo(&s, "\"%s\"=>\"%s\"", keystr, valstr);
    }
    PG_RETURN_CSTRING(s.data);
}

PG_FUNCTION_INFO_V1(${store_lower}_in);
Datum
${store_lower}_in(PG_FUNCTION_ARGS)
{
    ISParser     parser = {
        .keyin = ${keyin},
        .valin = int${valsize}in,
        .keysize = ${keysize},
        .valsize = ${valsize}};
    Store       *out;
    StorePairs  *pairs;
    AvlNode     *tree;
    int          n;

    parser.begin = PG_GETARG_CSTRING(0);

    if (parser.begin[0] == '\0')
    {
        EMPTY_ISTORE(out);
        PG_RETURN_POINTER(out);
    }

    tree = is_parse(&parser);

    pairs = palloc0(sizeof(StorePairs));
    n = is_tree_length(tree);
    ${store_lower}_pairs_init(pairs, n);
    ${store_lower}_tree_to_pairs(tree, pairs);
    istore_make_empty(tree);
    FINALIZE_${store_upper}(out, pairs);
    PG_RETURN_POINTER(out);
}

PG_FUNCTION_INFO_V1(${store_lower}_recv);
Datum
${store_lower}_recv(PG_FUNCTION_ARGS)
{
    Store      *result;
    StringInfo  buf = (StringInfo) PG_GETARG_POINTER(0);
    int         i = 0;
    StorePairs *creator = palloc0(sizeof *creator);
    int32       len = pq_getmsgint(buf, 4);

    ${store_lower}_pairs_init(creator, len);

    for (; i < len; ++i)
    {
#if ${keysize} <= 4
        Key key = pq_getmsgint(buf, ${keysize});
#elif ${keysize} == 8
        Key key = pq_getmsgint64(buf);
#endif

#if ${valsize} <= 4
        Val val = pq_getmsgint(buf, ${valsize});
#elif ${valsize} == 8
        Val val = pq_getmsgint64(buf);
#endif

        ${store_lower}_pairs_insert(creator, key, val);
    }
    FINALIZE_${store_upper}(result, creator);
    PG_RETURN_POINTER(result);
}

PG_FUNCTION_INFO_V1(${store_lower}_send);
Datum
${store_lower}_send(PG_FUNCTION_ARGS)
{
    Store     *in = PG_GETARG_STORE(0);
    StorePair *pairs= FIRST_PAIR(in, StorePair);
    int        i = 0;
    StringInfoData buf;

    pq_begintypsend(&buf);
    pq_sendint(&buf, in->len, 4);
    for (; i < in->len; ++i)
    {
#if ${keysize} <= 4
        pq_sendint(&buf, pairs[i].key, 4);
#elif ${keysize} == 8
        pq_sendint64(&buf, pairs[i].key);
#endif

#if ${valsize} <= 4
        pq_sendint(&buf, pairs[i].val, 4);
#elif ${valsize} == 8
        pq_sendint64(&buf, pairs[i].val);
#endif

    }
    PG_RETURN_BYTEA_P(pq_endtypsend(&buf));
}

PG_FUNCTION_INFO_V1(${store_lower}_to_json);
Datum
${store_lower}_to_json(PG_FUNCTION_ARGS)
{
    Store          *is = PG_GETARG_STORE(0);
    StorePair      *pairs;
    int             i;
    StringInfoData  dst;

    if (is->len == 0)
        PG_RETURN_TEXT_P(cstring_to_text_with_len("{}", 2));

    pairs   = FIRST_PAIR(is, StorePair);
    initStringInfo(&dst);
    appendStringInfoChar(&dst, '{');

    for (i = 0; i < is->len; i++)
    {
        appendStringInfoString(&dst, "\"");
        appendStringInfoString(&dst, (char *) DirectFunctionCall1(${keyout}, KeyGetDatum(pairs[i].key)));
        appendStringInfoString(&dst, "\": ");
        appendStringInfoString(&dst, (char *) DirectFunctionCall1(int${valsize}out, ValueGetDatum(pairs[i].val))); 
        if (i + 1 != is->len)
            appendStringInfoString(&dst, ", ");
    }
    appendStringInfoChar(&dst, '}');

    PG_RETURN_TEXT_P(cstring_to_text(dst.data));
}

#undef Store
#undef StorePair
#undef StorePairs
#undef Key
#undef Val
#undef KeyGetDatum
#undef ValueGetDatum
#undef PG_GETARG_STORE


%}

