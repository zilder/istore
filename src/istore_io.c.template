/*
 * input and output functions for istore
 */

#include "istore.h"
#include "is_parser.h"
#include "libpq/pqformat.h"
#include "fmgr.h"
#include "utils/builtins.h"
{%


/*
 * ${store_type} IO routines
 */

#define Store ${store_type}
#define StorePair ${store_type}Pair
#define StorePairs ${store_type}Pairs
#define Key int${keybits}
#define Val int${valbits}
#define KeyGetDatum Int${keybits}GetDatum
#define ValueGetDatum Int${valbits}GetDatum
#define PG_GETARG_STORE PG_GETARG_${store_type_upper}

PG_FUNCTION_INFO_V1(${store_type_lower}_out);
Datum
${store_type_lower}_out(PG_FUNCTION_ARGS)
{
    ${store_type} *in;
    int i;
    ${store_type}Pair *pairs;
    StringInfoData s;

    in = PG_GETARG_STORE(0);

    if (in->len == 0)
        PG_RETURN_CSTRING(palloc0(1));

    pairs = FIRST_PAIR(in, StorePair);
    initStringInfo(&s);

    for (i = 0; i<in->len; ++i)
    {
        char *keystr = (char *) DirectFunctionCall1(${keyout}, KeyGetDatum(pairs[i].key)); 
        char *valstr = (char *) DirectFunctionCall1(int${valsize}out, ValueGetDatum(pairs[i].val)); 

        if (i > 0)
            appendStringInfo(&s, ", \"%s\"=>\"%s\"", keystr, valstr);
        else
            appendStringInfo(&s, "\"%s\"=>\"%s\"", keystr, valstr);
    }
    PG_RETURN_CSTRING(s.data);
}

PG_FUNCTION_INFO_V1(${store_type_lower}_in);
Datum
${store_type_lower}_in(PG_FUNCTION_ARGS)
{
    ISParser     parser = {
        .keyin = ${keyin},
        .valin = int${valsize}in,
        .keysize = ${keysize},
        .valsize = ${valsize}};
    Store       *out;
    StorePairs  *pairs;
    AvlNode     *tree;
    int          n;

    parser.begin = PG_GETARG_CSTRING(0);

    if (parser.begin[0] == '\0')
    {
        EMPTY_ISTORE(out);
        PG_RETURN_POINTER(out);
    }

    tree = is_parse(&parser);

    pairs = palloc0(sizeof(StorePairs));
    n = is_tree_length(tree);
    ${store_type_lower}_pairs_init(pairs, n);
    ${store_type_lower}_tree_to_pairs(tree, pairs);
    istore_make_empty(tree);
    FINALIZE_${store_type_upper}(out, pairs);
    PG_RETURN_POINTER(out);
}

PG_FUNCTION_INFO_V1(${store_type_lower}_recv);
Datum
${store_type_lower}_recv(PG_FUNCTION_ARGS)
{
    Store *result;
    StringInfo buf = (StringInfo) PG_GETARG_POINTER(0);
    int i = 0;
    StorePairs *creator = palloc0(sizeof *creator);
    int32 len = pq_getmsgint(buf, 4);

    ${store_type_lower}_pairs_init(creator, len);

    for (; i < len; ++i)
    {
#if ${keysize} <= 4
        Key key = pq_getmsgint(buf, ${keysize});
#elif ${keysize} == 8
        Key key = pq_getmsgint64(buf);
#endif

#if ${valsize} <= 4
        Val val = pq_getmsgint(buf, ${valsize});
#elif ${valsize} == 8
        Val val = pq_getmsgint64(buf);
#endif

        ${store_type_lower}_pairs_insert(creator, key, val);
    }
    FINALIZE_${store_type_upper}(result, creator);
    PG_RETURN_POINTER(result);
}

PG_FUNCTION_INFO_V1(${store_type_lower}_send);
Datum
${store_type_lower}_send(PG_FUNCTION_ARGS)
{
    Store *in = PG_GETARG_STORE(0);
    StorePair *pairs= FIRST_PAIR(in, StorePair);
    int i = 0;
    StringInfoData buf;

    pq_begintypsend(&buf);
    pq_sendint(&buf, in->len, 4);
    for (; i < in->len; ++i)
    {
#if ${keysize} <= 4
        pq_sendint(&buf, pairs[i].key, 4);
#elif ${keysize} == 8
        pq_sendint64(&buf, pairs[i].key);
#endif

#if ${valsize} <= 4
        pq_sendint(&buf, pairs[i].val, 4);
#elif ${valsize} == 8
        pq_sendint64(&buf, pairs[i].val);
#endif

    }
    PG_RETURN_BYTEA_P(pq_endtypsend(&buf));
}

#undef Store
#undef StorePair
#undef StorePairs
#undef Key
#undef Val
#undef KeyGetDatum
#undef ValueGetDatum
#undef PG_GETARG_STORE


%}

