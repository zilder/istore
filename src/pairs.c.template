#include "avl.h"
#include "istore.h"

{%

/*
 * adds a key/ value pair for each subnode to IStorePairs
 * due to the nature of the AVL tree the pairs will be ordered by key
 */
void
${store_lower}_tree_to_pairs(AvlNode *p, ${store}Pairs *pairs)
{
    if (p == NULL)
        return;
    ${store_lower}_tree_to_pairs(p->left, pairs);
    ${store_lower}_pairs_insert(pairs, p->key, p->value);
    ${store_lower}_tree_to_pairs(p->right, pairs);
}

/*
 * initialize IStorePairs
 */
void
${store_lower}_pairs_init(${store}Pairs *pairs, size_t initial_size)
{
    pairs->pairs  = palloc0(initial_size * sizeof(${store}Pair));
    pairs->used   = 0;
    pairs->size   = initial_size;
    pairs->buflen = 0;
}

/*
 * insert key value to IStorePairs
 */
void
${store_lower}_pairs_insert(${store}Pairs *pairs, ${keytype} key, ${valtype} val)
{
    if (pairs->size == pairs->used)
    {
        if (pairs->used == PAIRS_MAX(${store}Pair))
            elog(ERROR, "${store_lower} can't have more than %lu keys", PAIRS_MAX(${store}Pair));

        pairs->size *= 2;
        // overflow check pairs->size should have been grown but not exceed PAIRS_MAX(${store}Pair)
        if (pairs->size < pairs->used || pairs->size > PAIRS_MAX(${store}Pair))
            pairs->size = PAIRS_MAX(${store}Pair);

        pairs->pairs = repalloc(pairs->pairs, pairs->size * sizeof(${store}Pair));
    }

    pairs->pairs[pairs->used].key = key;
    pairs->pairs[pairs->used].val = val;
    //pairs->buflen += digits32(key) + digits32(val) + BUFLEN_OFFSET;

    if (pairs->buflen < 0)
        elog(ERROR, "${store_lower} buffer overflow");
    pairs->used++;
}

%}
